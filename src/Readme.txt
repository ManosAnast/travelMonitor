Για τις δομές αυτής της εργασίας χρησιμοποίησα ότι είχα υλοποιήσει στην 1η εργασία. Με την διαφορά ότι, πλέον δεν έχω skiplist αλλά, μια απλή linked list. Επίσης, η δομής Country ενώ στην προηγούμενη εργασία ο ρόλος της ήταν να κρατάει ένα αρχείο απο τις χώρες που έχουμε στην βάση μας, τώρα κρατάει παράλληλα ένα Id, το οποίο είναι το id του monitor που αντιπροσωπεύει την χώρα αυτή, και ένα pid το οποίο είναι το process id που αντιστοιχεί στο monitor. Την χρησιμοποιώ στο travelmonitor για να μπορώ να στέλνω τα signal και να ανοίγω τα σωστά fifo.


Fifo(Fifo.c/Fifo.h):
Για την επικοινωνία ανάμεσα στα processes χρησιμοποιώ 2 Fifo. Το ένα είναι για την μεταφορά των bloomfilter(Fifo_init,Fifo_write,Fifo_read) και το άλλο είναι για την μεταφορά των commands(Fifo_writeCommands,Fifo_readCommands) απο το travelmonitor στα monitors και την μεταφορά των αποτελεσμάτων απο τα monitors στο travelmonitor. Έχω χρησιμοποιήσει την select στο read της fifo που περιμένει κάποια εντολή απο το travelmonitor και για τον συγχρονισμό στο signal send για το addVaccinationRecords.
Το travelmonitor κάνει το initialize των fifo για τα bloomfilter μέσω της fifo_init, ενώ τα monitor είναι υπεύθυνα για την αρχικοποίηση των fifo για τα commands και τα αποτελέσματα που αντιστοιχούν σε αυτά.
Οι fifo στέλνουν όλα τα bytes που έχουν να στείλουν. Μετά διαβάζουν σε κομμάτι. Αυτό το έκανα γιατί στην εκφώνηση λέτε "Η παράμετρος bufferSize: είναι το μέγεθος του buffer για διάβασμα πάνω από τα pipes."


Serialization(serialize.c/serialize.h):
Για την αποστολή μέσω fifo, κάνω serialization. Έχω ουσιαστικά 2 set τέτοιων συναρτήσεων. Ένα set κάνει serialize και unserialize τα bloomfilter και χρησιμοποιείται για την αποστολή και αποδοχή τους(serialize_bloom/userialize_bloom). Μετά, το άλλο set χρησιμοποιείται για την αποστολή και την αποδοχή των commands, αλλά και για την αποστολή και αποδοχή των αποτελεσμάτων(serialize_commands/unserialize_commands). Οι συναρτήσεις αυτές χρησιμοποιούνται σε συνδιασμό με τις συναρτήσεις των fifo.


SignalHandling(signal.c/signal.h):
Το signal handling γίνεται μέσω κάποιον global flag μεταβλητών. Αν έχει σταλεί κάποιο signal, τότε το αντίστοιχο flag θα γίνει 1 απο 0 και θα κάνει μετά τον πρόγραμμα τις αντίστοιχες ενέργειες που χρειάζεται. 
Για την αποστολή του SIGUSR1, το travelmonitor χρησιμοποιεί μια συνάρτηση, την SendSignal. Η συνάρτηση αυτή στέλνει με kill, στο κατάλληλο monitor, το signal και μετά ανοίγει στέλνει μέσω του αντίστοιχου fifo ένα κενό μήνυμα, για να ενεργοποιήσει το TTY του monitor. Μετά, παίρνει σειρά το monitor. Καλεί την addVaccinationRecrods, στέλνει ένα μήνυμα στο travelmonitor, επιστρέφει και κάνει το flag πάλι 0.
Η αποστολή του SIGINT και του SIGQUIT ενεργοποιεί τον ίδιο handler. Το monitor κάνει break στο TTY και επιστρέφει. 



Script:
Εφόσον ξέρουμε τον τύπο γραφής των εισαγωγών, λέω ότι στην αρχή στην 4η θέση άρα array[3] θα είναι το country. Επομένως, το χρησιμοποιώ για να φτιάξω το input_dir του και τα files του. Στην συνέχεια άμα κάνουμε άλλα 3 βήματα καταλήγουμε στο vaccinated status. Άν είναι όχι, δεν θα έχει η εγγραφή μας date. Επομένως, για να φτάσουμε στο country του επόμενου citizen θα πρέπει να κάνουμε 4 βήματα. Στην περίπτωση που ο citizen που εξετάζουμε τώρα είναι vaccinated, τότε η εγγραφή θα έχει date. Επομένως, για να φτάσουμε στο country του επόμενου citizen θα πρέπει να κάνουμε 5 βήματα. Αυτά αντιπροσωπεύονται απο το index i στο script μας. Δουλεύω με αυτή την λογική και τις 2 while που έχει το script. 
Για το 2ο while: Παράλληλα με αυτόν τον πίνακα(κάθε λέξη είναι ένα object) όμως, έχουμε και έναν άλλον πίνακα ο οποίος είναι χωρισμένος στις αλλαγές γραμμής. Για αυτόν τον πίνακα έχουμε το index k. Αυτό με κάθε μια λούπα που κάνουμε κάνει +1. Αυτό γίνεται γιατί σε κάθε μια καινούργια λούπα ουσιαστικά ασχολούμαστε και με ένα καινούργιο entry.
